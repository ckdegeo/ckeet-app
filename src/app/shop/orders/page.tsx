'use client';

import { useEffect, useState, useCallback } from 'react';
import { Store } from '@/lib/types';
import StoreNavbar from '../patterns/storeNavbar';
import Footer from '../patterns/footer';
import Table from '@/app/components/tables/table';
import Search from '@/app/components/inputs/search';
import { Download, Eye, Copy, CheckCircle, ArrowLeft, RefreshCw } from 'lucide-react';
import { showSuccessToast, showErrorToast } from '@/lib/utils/toastUtils';
import { useCache } from '@/lib/hooks/useCache';
import NumberCard from '@/app/components/cards/numberCard';
import Badge from '@/app/components/ui/badge';
import ContentModal from '@/app/components/modals/contentModal';

interface Transaction {
  id: string;
  orderId: string;
  paymentId: string;
  status: string;
  amount: number;
  createdAt: string;
  updatedAt: string;
}

interface OrderItem {
  id: string;
  orderNumber: string;
  orderId: string;
  productId: string;
  productName: string;
  productDescription?: string;
  productPrice: number;
  quantity: number;
  orderStatus: string;
  paymentStatus: string;
  deliveredContent: string;
  downloadUrl?: string;
  deliverables?: Array<{
    id: string;
    name: string;
    url: string;
  }>;
  expiresAt?: string;
  isDownloaded: boolean;
  downloadCount: number;
  storeName: string;
  storeSubdomain: string;
  storePrimaryColor?: string;
  storeSecondaryColor?: string;
  createdAt: string;
  updatedAt: string;
  transactions: Transaction[];
  latestTransaction?: Transaction;
  customerEmail: string;
  customerName: string;
  customerPhone: string;
  totalAmount: number;
  paymentMethod: string;
}

export default function OrdersPage() {
  const [store, setStore] = useState<Store | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userName, setUserName] = useState<string>();
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedOrder, setSelectedOrder] = useState<OrderItem | null>(null);
  const [isContentModalOpen, setIsContentModalOpen] = useState(false);

  // Cache para dados da loja
  const { data: storeData, loading: storeLoading } = useCache(
    async () => {
      const hostname = window.location.hostname;
      const subdomain = hostname.split('.')[0];
      
      const response = await fetch(`/api/storefront/store?subdomain=${subdomain}`);
      
      if (!response.ok) {
        throw new Error('Loja n√£o encontrada');
      }

      return await response.json();
    },
    {
      key: 'store_data',
      duration: 2 * 60 * 1000, // Reduzido para 2 minutos para atualizar cores mais rapidamente
      userId: (() => {
        try {
          if (typeof window === 'undefined') return null;
          const token = localStorage.getItem('customer_access_token');
          if (token) {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return payload.userId || payload.sub || null;
          }
        } catch (error) {
          console.error('Erro ao obter userId do token:', error);
        }
        return null;
      })(),
    }
  );

  // Estados para orders (SEM cache para atualiza√ß√£o instant√¢nea)
  interface PurchaseItemRaw {
    id: string;
    orderNumber: string;
    orderId: string;
    productId: string;
    productName: string;
    productDescription?: string;
    productPrice: number;
    quantity: number;
    orderStatus: string;
    paymentStatus?: string;
    deliveredContent?: string;
    downloadUrl?: string;
    deliverables?: Array<{
      name: string;
      url: string;
    }>;
    expiresAt?: string;
    isDownloaded: boolean;
    downloadCount: number;
    storeName: string;
    storeSubdomain?: string;
    storePrimaryColor?: string;
    storeSecondaryColor?: string;
    createdAt: string;
    updatedAt: string;
    transactions?: Transaction[];
    latestTransaction?: Transaction;
    customerEmail: string;
    customerName?: string;
    customerPhone?: string;
    totalAmount: number;
    paymentMethod?: string;
  }

  interface OrdersData {
    purchases?: PurchaseItemRaw[];
    stats?: {
      totalOrders: number;
      totalPurchases: number;
      deliveredPurchases: number;
      pendingPurchases: number;
      paidOrders: number;
      totalDownloads: number;
      totalAmount: number;
    };
  }
  const [ordersData, setOrdersData] = useState<OrdersData | null>(null);
  const [ordersLoading, setOrdersLoading] = useState(true);
  const [ordersError, setOrdersError] = useState<string | null>(null);

  // Fun√ß√£o para buscar orders
  const fetchOrders = async () => {
    try {
      setOrdersLoading(true);
      const accessToken = localStorage.getItem('customer_access_token');
      if (!accessToken) {
        throw new Error('Token de acesso n√£o encontrado');
      }

      const response = await fetch('/api/customer/orders/list?_t=' + Date.now(), {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
        },
        cache: 'no-store'
      });

      if (!response.ok) {
        throw new Error('Erro ao buscar pedidos');
      }

      const data = await response.json();
      setOrdersData(data);
      setOrdersError(null);
    } catch (error) {
      console.error('Erro ao buscar pedidos:', error);
      setOrdersError(error instanceof Error ? error.message : 'Erro desconhecido');
    } finally {
      setOrdersLoading(false);
    }
  };

  // Buscar orders ao montar o componente
  useEffect(() => {
    fetchOrders();
  }, []);

  // Fallback para refreshOrders (caso seja usado em outros lugares)
  const refreshOrders = () => {
    fetchOrders();
  };

  useEffect(() => {
    checkAuthentication();
  }, []);

  // Invalida√ß√£o autom√°tica do cache quando a p√°gina ganha foco
  useEffect(() => {
    const handleFocus = () => {
      // Refresh autom√°tico quando a p√°gina ganha foco (usu√°rio volta da aba)
      refreshOrders();
    };

    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Refresh quando a p√°gina fica vis√≠vel novamente
        refreshOrders();
      }
    };

    // Listener para detectar mudan√ßas no localStorage (novas compras e mudan√ßas na loja)
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'customer_access_token' || e.key?.includes('order') || e.key?.includes('store')) {
        // Invalidar cache quando h√° mudan√ßas relacionadas a pedidos ou loja
        refreshOrders();
        // Tamb√©m invalidar cache da loja se houver mudan√ßas relacionadas √† loja
        if (e.key?.includes('store')) {
          window.location.reload(); // Recarregar para pegar novas cores
        }
      }
    };

    window.addEventListener('focus', handleFocus);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('focus', handleFocus);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [refreshOrders]);

  useEffect(() => {
    if (storeData) {
      setStore(storeData.store);
    }
  }, [storeData]);

  // Fun√ß√£o para verificar entrega de conte√∫do
  const checkDelivery = useCallback(async () => {
    try {
      console.log('üîç [POLLING] Verificando se h√° conte√∫do para entregar...');
      const accessToken = localStorage.getItem('customer_access_token');
      if (!accessToken) {
        console.log('‚ö†Ô∏è [POLLING] Sem customer_access_token');
        return;
      }

      console.log('üì° [POLLING] Chamando /api/customer/orders/check-delivery');
      const response = await fetch('/api/customer/orders/check-delivery', {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        cache: 'no-store'
      });

      console.log('üìä [POLLING] Response status:', response.status);

      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ [POLLING] Data recebida:', data);
        if (data.success && data.delivered > 0) {
          console.log('üéâ [POLLING] Conte√∫do entregue! Atualizando p√°gina...');
          // Refresh orders para mostrar conte√∫do entregue
          await fetchOrders();
        }
      }
    } catch (error) {
      console.error('‚ùå [POLLING] Erro:', error);
    }
  }, [fetchOrders]);

  // Checar apenas uma vez ao carregar a p√°gina
  useEffect(() => {
    checkDelivery();
  }, [checkDelivery]);

  useEffect(() => {
    if (ordersError) {
      // S√≥ mostra erro se for um erro real de servidor (500) ou de autentica√ß√£o (401/403)
      // N√£o mostra erro para usu√°rios novos sem pedidos (que √© normal)
      const errorMessage = ordersError || '';
      const isRealError = errorMessage.includes('Erro interno do servidor') || 
                         errorMessage.includes('Token de acesso √© obrigat√≥rio') ||
                         errorMessage.includes('Token inv√°lido') ||
                         errorMessage.includes('Customer n√£o encontrado');
      
      if (isRealError) {
        showErrorToast('Erro ao carregar pedidos');
      }
    }
  }, [ordersError]);

  function checkAuthentication() {
    const accessToken = localStorage.getItem('customer_access_token');
    const userData = localStorage.getItem('customer_user_data');
    
    if (accessToken && userData) {
      try {
        const user = JSON.parse(userData);
        setIsAuthenticated(true);
        setUserName(user.name);
      } catch (error) {
        console.error('Erro ao parsear dados do usu√°rio:', error);
        setIsAuthenticated(false);
        setUserName(undefined);
      }
    } else {
      setIsAuthenticated(false);
      setUserName(undefined);
    }
  }

  const handleDownload = async (purchaseId: string, downloadUrl: string) => {
    try {
      // Implementar l√≥gica de download
      window.open(downloadUrl, '_blank');
      showSuccessToast('Download iniciado!');
    } catch (error) {
      console.error('Erro no download:', error);
      showErrorToast('Erro ao fazer download');
    }
  };

  const handleCopyContent = async (content: string) => {
    try {
      await navigator.clipboard.writeText(content);
      showSuccessToast('Conte√∫do copiado para a √°rea de transfer√™ncia!');
    } catch (error) {
      console.error('Erro ao copiar:', error);
      showErrorToast('Erro ao copiar conte√∫do');
    }
  };

  const handleViewContent = (item: OrderItem) => {
    setSelectedOrder(item);
    setIsContentModalOpen(true);
  };

  // Preparar dados para a tabela usando purchases
  const purchases = ordersData?.purchases || [];
  const stats = ordersData?.stats || {
    totalOrders: 0,
    totalPurchases: 0,
    deliveredPurchases: 0,
    pendingPurchases: 0,
    paidOrders: 0,
    totalDownloads: 0,
    totalAmount: 0
  };

  const tableData: OrderItem[] = purchases.map((purchase) => ({
    id: purchase.id,
    orderNumber: purchase.orderNumber,
    orderId: purchase.orderId,
    productId: purchase.productId,
    productName: purchase.productName,
    productDescription: purchase.productDescription,
    productPrice: purchase.productPrice,
    quantity: purchase.quantity,
    orderStatus: purchase.orderStatus,
    paymentStatus: purchase.paymentStatus || '',
    deliveredContent: purchase.deliveredContent || '',
    downloadUrl: purchase.downloadUrl,
    deliverables: purchase.deliverables?.map((d: { name: string; url: string }) => ({
      id: '',
      name: d.name,
      url: d.url
    })) || [],
    expiresAt: purchase.expiresAt,
    isDownloaded: purchase.isDownloaded,
    downloadCount: purchase.downloadCount,
    storeName: purchase.storeName,
    storeSubdomain: purchase.storeSubdomain || '',
    storePrimaryColor: purchase.storePrimaryColor,
    storeSecondaryColor: purchase.storeSecondaryColor,
    createdAt: purchase.createdAt,
    updatedAt: purchase.updatedAt,
    transactions: purchase.transactions || [],
    latestTransaction: purchase.latestTransaction,
    customerEmail: purchase.customerEmail,
    customerName: purchase.customerName || '',
    customerPhone: purchase.customerPhone || '',
    totalAmount: purchase.totalAmount,
    paymentMethod: purchase.paymentMethod || ''
  }));

  // Filtrar dados baseado na busca
  const filteredData = tableData.filter((item: typeof tableData[0]) => 
    item.productName.toLowerCase().includes(searchTerm.toLowerCase()) ||
    item.orderNumber.toLowerCase().includes(searchTerm.toLowerCase()) ||
    item.orderStatus.toLowerCase().includes(searchTerm.toLowerCase()) ||
    item.paymentStatus?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    item.productDescription?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const columns = [
    {
      key: 'orderNumber' as keyof OrderItem,
      label: 'Pedido',
      width: 'w-40',
      render: (value: unknown) => `#${value}`,
    },
    {
      key: 'productName' as keyof OrderItem,
      label: 'Produto',
      width: 'w-48',
    },
    {
      key: 'deliveredContent' as keyof OrderItem,
      label: 'Conte√∫do',
      width: 'w-32',
      render: (value: unknown, item: OrderItem) => {
        // S√≥ mostra "Entregue" se o pedido estiver pago E tiver conte√∫do
        if (item.orderStatus === 'PAID' && value) {
          return 'Entregue';
        }
        return 'Pendente';
      },
    },
    {
      key: 'orderStatus' as keyof OrderItem,
      label: 'Status',
      width: 'w-28',
      render: (value: unknown) => {
        const statusMap: Record<string, string> = {
          PENDING: 'Pendente',
          PAID: 'Pago',
          DELIVERED: 'Entregue',
          CANCELLED: 'Cancelado',
          REFUNDED: 'Reembolsado',
        };
        const statusText = statusMap[value as string] || (value as string);
        return (
          <Badge 
            status={statusText} 
            primaryColor={store?.primaryColor} 
            secondaryColor={store?.secondaryColor} 
          />
        );
      },
    },
    {
      key: 'paymentMethod' as keyof OrderItem,
      label: 'Pagamento',
      width: 'w-28',
      render: (value: unknown) => {
        const methodMap: Record<string, string> = {
          PIX: 'PIX',
          CREDIT_CARD: 'Cart√£o de Cr√©dito',
          DEBIT_CARD: 'Cart√£o de D√©bito',
          BOLETO: 'Boleto',
          TRANSFER: 'Transfer√™ncia',
        };
        const method = methodMap[value as string] || 'PIX';
        return (
          <Badge 
            status={method} 
            primaryColor={store?.primaryColor} 
            secondaryColor={store?.secondaryColor} 
          />
        );
      },
    },
    {
      key: 'totalAmount' as keyof OrderItem,
      label: 'Valor',
      width: 'w-24',
      render: (value: unknown) => `R$ ${(value as number).toFixed(2)}`,
    },
    {
      key: 'createdAt' as keyof OrderItem,
      label: 'Data',
      width: 'w-28',
      render: (value: unknown) => new Date(value as string).toLocaleDateString('pt-BR'),
    },
  ];

  const actions = [
    {
      icon: Eye,
      label: 'Ver Conte√∫do',
      onClick: (item: OrderItem) => {
        if (item.orderStatus === 'PAID' && item.deliveredContent) {
          handleViewContent(item);
        } else {
          showErrorToast('Conte√∫do ainda n√£o foi entregue');
        }
      },
      show: (item: OrderItem) => item.orderStatus === 'PAID' && !!item.deliveredContent,
    },
    {
      icon: Copy,
      label: 'Copiar Conte√∫do',
      onClick: (item: OrderItem) => {
        if (item.orderStatus === 'PAID' && item.deliveredContent) {
          handleCopyContent(item.deliveredContent);
        } else {
          showErrorToast('Conte√∫do ainda n√£o foi entregue');
        }
      },
      show: (item: OrderItem) => item.orderStatus === 'PAID' && !!item.deliveredContent,
    },
    {
      icon: Download,
      label: 'Download',
      onClick: (item: OrderItem) => {
        if (item.orderStatus === 'PAID') {
          if (item.downloadUrl) {
            handleDownload(item.id, item.downloadUrl);
          } else if (item.deliverables && item.deliverables.length > 0) {
            // Se n√£o tem downloadUrl mas tem deliverables, usar o primeiro
            handleDownload(item.id, item.deliverables[0].url);
          } else {
            showErrorToast('Download n√£o dispon√≠vel');
          }
        } else {
          showErrorToast('Pedido ainda n√£o foi pago');
        }
      },
      show: (item: OrderItem) => item.orderStatus === 'PAID' && !!(item.downloadUrl || (item.deliverables && item.deliverables.length > 0)),
    },
  ];

  if (storeLoading || ordersLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"></div>
      </div>
    );
  }

  if (!store) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">Loja n√£o encontrada</h1>
          <p className="text-gray-600">O dom√≠nio solicitado n√£o est√° configurado.</p>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-gray-50">
        <StoreNavbar
          store={store}
          isAuthenticated={false}
          onLoginClick={() => window.location.href = '/shop/auth/login'}
          onRegisterClick={() => window.location.href = '/shop/auth/register'}
        />
        
        <div className="flex items-center justify-center min-h-[60vh]">
          <div className="text-center">
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Acesso negado</h1>
            <p className="text-gray-600 mb-6">Voc√™ precisa estar logado para ver seus pedidos.</p>
            <div className="flex justify-center">
              <button
                onClick={() => window.location.href = '/shop/auth/login'}
                className="px-8 py-3 text-md rounded-full transition-all flex items-center gap-2 cursor-pointer hover:opacity-90 font-medium"
                style={{ 
                  backgroundColor: store.primaryColor || '#bd253c',
                  color: 'white',
                  border: `2px solid ${store.primaryColor || '#bd253c'}`
                }}
              >
                Fazer login
              </button>
            </div>
          </div>
        </div>

        <Footer store={store} />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Navbar */}
      <StoreNavbar
        store={store}
        isAuthenticated={isAuthenticated}
        userName={userName}
        onLoginClick={() => window.location.href = '/shop/auth/login'}
        onRegisterClick={() => window.location.href = '/shop/auth/register'}
      />

      {/* Conte√∫do Principal */}
      <main className="container mx-auto px-8 py-12">
        {/* Header com Bot√£o de Voltar */}
        <div className="flex items-center justify-between mb-8">
          <h1 
            className="text-3xl font-bold"
            style={{ color: store.primaryColor || '#bd253c' }}
          >
            Pedidos
          </h1>
          
          <button
            onClick={() => window.location.href = '/shop'}
            className="px-8 py-3 text-md rounded-full transition-all flex items-center gap-2 cursor-pointer hover:opacity-90"
            style={{
              backgroundColor: store.secondaryColor || '#970b27',
              color: 'white',
              border: `2px solid ${store.secondaryColor || '#970b27'}`
            }}
          >
            <ArrowLeft className="w-4 h-4" />
            Voltar
          </button>
        </div>

        {/* Estat√≠sticas R√°pidas */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          <NumberCard
            title="Total de pedidos"
            value={ordersLoading ? '...' : stats.totalOrders}
            icon={CheckCircle}
            background="transparent"
            className={`shadow-sm border border-gray-100 ${ordersLoading ? 'opacity-75' : ''}`}
            style={{
              '--primary': store.primaryColor || '#bd253c',
              '--secondary': store.secondaryColor || '#970b27',
              '--background': '#ffffff',
              '--foreground': '#111827',
              '--on-background': '#6b7280',
              '--on-primary': '#ffffff'
            } as React.CSSProperties}
          />

          <NumberCard
            title="Pedidos pagos"
            value={ordersLoading ? '...' : stats.paidOrders}
            icon={Download}
            background="transparent"
            className={`shadow-sm border border-gray-100 ${ordersLoading ? 'opacity-75' : ''}`}
            style={{
              '--primary': store.secondaryColor || '#970b27',
              '--secondary': store.primaryColor || '#bd253c',
              '--background': '#ffffff',
              '--foreground': '#111827',
              '--on-background': '#6b7280',
              '--on-primary': '#ffffff'
            } as React.CSSProperties}
          />

          <NumberCard
            title="Downloads realizados"
            value={ordersLoading ? '...' : stats.totalDownloads}
            icon={Eye}
            background="transparent"
            className={`shadow-sm border border-gray-100 ${ordersLoading ? 'opacity-75' : ''}`}
            style={{
              '--primary': store.primaryColor || '#bd253c',
              '--secondary': store.secondaryColor || '#970b27',
              '--background': '#ffffff',
              '--foreground': '#111827',
              '--on-background': '#6b7280',
              '--on-primary': '#ffffff'
            } as React.CSSProperties}
          />
        </div>

        {/* Tabela de Pedidos */}
        <div className="bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden">
          <div className="p-6 border-b border-gray-100">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div className="flex items-center gap-3">
                <div>
                  <h2 className="text-xl font-semibold text-gray-900">Comprados</h2>
                </div>
                
                {/* Bot√£o de Refresh */}
                <button
                  onClick={() => {
                    refreshOrders();
                    checkDelivery();
                  }}
                  disabled={ordersLoading}
                  className="cursor-pointer p-2 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Atualizar lista de pedidos"
                >
                  <RefreshCw 
                    size={18} 
                    className={`text-gray-600 ${ordersLoading ? 'animate-spin' : ''}`} 
                  />
                </button>
              </div>
              
              {/* Componente de Busca */}
              <div className="w-full sm:w-80">
                <Search
                  placeholder="Buscar por produto, pedido ou status..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  primaryColor={store.primaryColor}
                  secondaryColor={store.secondaryColor}
                />
              </div>
            </div>
          </div>
          
          <div className="p-6">
            <Table
              data={filteredData}
              columns={columns}
              actions={actions}
              itemsPerPage={10}
              emptyMessage="Nenhum pedido encontrado. Fa√ßa sua primeira compra!"
              primaryColor={store.primaryColor}
              secondaryColor={store.secondaryColor}
            />
          </div>
        </div>
      </main>

      {/* Footer */}
      <Footer store={store} />

      {/* Modal de Conte√∫do */}
      {selectedOrder && (
        <ContentModal
          isOpen={isContentModalOpen}
          onClose={() => {
            setIsContentModalOpen(false);
            setSelectedOrder(null);
          }}
          orderData={selectedOrder}
          primaryColor={store?.primaryColor}
          secondaryColor={store?.secondaryColor}
        />
      )}
    </div>
  );
}